<!-- Autogenerated: Edit `README.md.tpl` and run `zig build readme` -->

# args-lex [![CI Status][ci-badge]][ci-url] ![License: MIT][license-badge]

[ci-badge]: https://github.com/knutwalker/args-lex/actions/workflows/checks.yml/badge.svg
[ci-url]: https://github.com/knutwalker/args-lex
[license-badge]: https://img.shields.io/badge/license-MIT-blue.svg?style=shield

A lexer to parse command line arguments

> [!NOTE]
> This is not a full CLI parser.
> A lot of functionality is intentionally missing.

## Features / Parsing capabilities*

- Long arguments: `--flag`
    - values separated by space or `=` (`--flag=value`, `--flag value`)
    - multiple occurrences: `--flag one --flag two`
- Short arguments: `-a`
    - multiple flags grouped together: `-abc`
    - values separated by space or `=` (`-a=value`, `-a value`, `-avalue`)
    - repeated flags: `-vvvv`
- Positional arguments: `arg`
    - escaping remaining arguments after `--`

_*_: Some of those features are not directly implemented by this library.
However, parsers written using the lexer can choose to support those features
and are not locked out of anything.

## Non-Features

- help generation
- arguments to type mapping
- builder API

## Installation

Update to latest version:

```sh
zig fetch --save git+https://github.com/knutwalker/args-lex.git
```

Add to `build.zig`:

```zig
exe.root_module.addImport("args-lex", b.dependency("args-lex", .{}).module("args-lex"));
```

> [!IMPORTANT]
> `args-lex` tracks Zig `0.13.0`

## Examples

### Demo

A simple demo, showing the basics of the API:

```zig
const std = @import("std");

const args_lex = @import("args_lex");

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();

    var args = try args_lex.Args.init(arena.allocator());
    defer args.deinit();

    while (args.next()) |arg| {
        switch (arg.*) {
            .escape => while (args.nextValue()) |value| {
                std.debug.print("POSITIONAL: {s}\n", .{value});
            },
            .shorts => |*shorts| while (shorts.next()) |short| switch (short) {
                .flag => |flag| std.debug.print("-{u}\n", .{flag}),
                .suffix => |s| std.debug.print("non utf8 flag: {any}\n", .{s}),
            },
            .long => |long| {
                std.debug.print("--{s}", .{long.flag});
                if (long.value) |v| std.debug.print("={s}", .{v});
                std.debug.print("\n", .{});
            },
            .value => |v| std.debug.print("POSITIONAL: {s}\n", .{v}),
        }
    }
}

```

## License

args-lex is licensed under the [MIT License](http://opensource.org/licenses/MIT)

---

<!-- vim: set ft=markdown: -->
